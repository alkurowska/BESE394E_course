---
title: "DAY2 GSE198256"
author: "David Gomez-Cabrero"
date: "2024-January"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Experimental design

Lets review experimental design from a practical perspective

```{r read data}

# Read data
urld <- "https://www.ncbi.nlm.nih.gov/geo/download/?format=file&type=rnaseq_counts"
path <- paste(urld, "acc=GSE198256", "file=GSE198256_raw_counts_GRCh38.p13_NCBI.tsv.gz", sep="&");
GSE198256_count <- as.matrix(data.table::fread(path, header=T, colClasses="integer"), rownames=1)

# Read Meta data
library(GEOquery)
gds <- getGEO("GSE198256")
Meta_GSE198256 <- pData(gds$GSE198256_series_matrix.txt.gz@phenoData)
#head(Meta_GSE198256) #explore metadata
Group <- as.data.frame(Meta_GSE198256[,c("disease state:ch1")])

rownames(Group) <- rownames(Meta_GSE198256)
colnames(Group) <- c("Group")

#dim(GSE198256_count) #39376 x 34

```

## Limma: Normalize and set design

```{r Normalize and set design}

# set DGE class
require(limma)
require(edgeR)

# Make sure on the metadata
#sum(rownames(Meta_GSE198256)==colnames(GSE198256_count)) #34
Group$Group <- gsub("Covid19: Acute infection", "Covid19AI", Group$Group)
Group$Group <- gsub("Covid19: Recovery 3Mo", "Covid193Mo", Group$Group)
Group$Group <- gsub("Covid19: Recovery 6Mo", "Covid196Mo", Group$Group)

group <- as.factor(Group$Group)
design <- model.matrix(~ group ) #With intercept
colnames(design) <- gsub("group", "", colnames(design))

dge <- DGEList(counts=GSE198256_count, samples = Group)

# Filter low counts
keep <- filterByExpr(dge, design=design)
table(keep)
#FALSE  TRUE 
#22967 16409 
dge <- dge[keep,,keep.lib.sizes=FALSE]

# Normalization TMM
dge <- calcNormFactors(dge, method = "TMM")


```

## Limma: Voom or Trend?

```{r Voom or Trend}

## Trend

# If the sequencing depth is reasonably consistent across the RNA samples, then the simplest and most robust approach to differential exis to use limma-trend. This approach will usually work well if the ratio of the largest library size to the smallest is not more than about 3-fold.
logCPM <- cpm(dge, log=TRUE, prior.count=3)
 # The prior count is used here to damp down the variances of logarithms of low counts.
fit_t <- lmFit(logCPM, design)

fit_t <- eBayes(fit_t, trend=TRUE)
 # logical, should an intensity-dependent trend be allowed for the prior variance? If FALSE then the prior variance is constant. Alternatively, trend can be a row-wise numeric vector, which will be used as the covariate for the prior variance.
 # The use of eBayes or treat with trend=TRUE is known as the limma-trend method (Law et al, 2014; Phipson et al, 2016). With this option, an intensity-dependent trend is fitted to the prior variances s2.prior

res_t <- topTable(fit_t, coef=ncol(design), sort.by = "none", number = nrow(dge))

## Voom

# When the library sizes are quite variable between samples, then the voom approach is theoretically more powerful than limma-trend.
v <- voom(dge, design, plot=TRUE)
# The voom method is similar in purpose to the limma-trend method, which uses eBayes or treat with trend=TRUE. The voom method incorporates the mean-variance trend into the precision weights, whereas limma-trend incorporates the trend into the empirical Bayes moderation. The voom method takes into account the sequencing depths (library sizes) of the individual columns of counts and applies the mean-variance trend on an individual observation basis. limma-trend, on the other hand, assumes that the library sizes are not wildly different and applies the mean-variance trend on a genewise basis. As noted by Law et al (2014), voom should be more powerful than limma-trend if the library sizes are very different but, otherwise, the two methods should give similar results.
fit_v <- lmFit(v, design)
fit_v <- eBayes(fit_v)
#topTable(fit_v, coef=ncol(design)) # by default its comparing last column from the design vs the one of the intercept

res_v <- topTable(fit_v, coef=ncol(design), sort.by = "none", number = nrow(dge))


```

## ACTIVITY 1:

-   How would you compare the results between voom and trend?
Answer: See the code below.

-   Is it required to run more than analysis?
Not really. The goal is to understand your data type, data quality and choose methods accordingly. 

-   What exactly are we asking with this differential expression?
In the topTable() function we are using ncol(design) as our coef argument. In this case coef equals to `r ncol(design)`, which is our last column in a design matrix, which corresponds to `r colnames(design)[ncol(design)]` samples. Since I used a design with an intercept, the statistical results are in the context of a chosen group's (`r colnames(design)[ncol(design)]`) expression relative to a baseline - first group used to create the design matrix: `r levels(group)[1]` samples.  

```{r ACTIVITY 1}

#How would you compare the results between voom and trend?

# 1. Check number of DE genes in both methods 
voom_DE_down <- res_v[res_v$logFC < -1 & res_v$adj.P.Val < 0.05,] #441
voom_DE_up <- res_v[res_v$logFC > 1 & res_v$adj.P.Val < 0.05,] #406

trend_DE_down <- res_v[res_v$logFC < -1 & res_v$adj.P.Val < 0.05,] #441
trend_DE_up <- res_v[res_v$logFC > 1 & res_v$adj.P.Val < 0.05,] #406

# After applying both methods, we can see the same number of obtained up- and down- regulated genes. 

# 2. Let's check their overlap
library(ggVennDiagram)
toVenn <- list(rownames(voom_DE_down), rownames(voom_DE_up), rownames(trend_DE_down), rownames(trend_DE_up))

ggVennDiagram(toVenn, category.names = c("voomDown", "voomUp", "trendDown", "trendUp"))

# Both RNA-seq data transformation allowed for detection exactly the same genes. 

# 3. Compare Log2FC
#Check if data from voom and trend are ordered the same
table(rownames(res_v) == rownames(res_t))
plot(res_v$logFC, res_t$logFC)

# 4. Compare p.values
plot(res_v$adj.P.Val, res_t$adj.P.Val)


# We can see a fairly simmilar log2FC and adj.pvalues across the results based on two methods. Plot follow a linear trend diagonally with a bit sparsness towards the genes having insignificant differentiall expression. 
# 5. Correlation of log2FC
cor(res_v$logFC, res_t$logFC, method = "spearman")

# A Spearman's orrelation of log2FC from both methods is 0.9781146, meaning the methods have similar quantitaitve results. 

# Other options to compare the results would be ploting the MA plot for each method or volcano plots to see the magnitude of change. But we can already see that both methods performed equally well, and there is no need for more investigations. 

```

## ACTIVITY 2:

-   Plan the next analysis: questions, steps,...

Define differentially expressed genes between COVID19 samples and Healthy, for all of the recovery stages. Additionallay, I will investigate the differences between three COVID19 recovery stages and look for commonalities. 

```{r ACTIVITY 2}

# PACKAGES
#BiocManager::install("clusterProfiler", update = FALSE)
#BiocManager::install("ggupset", update = FALSE)
#BiocManager::install("msigdbr", update = FALSE)
#BiocManager::install("org.Hs.eg.db", update = FALSE)

library(clusterProfiler)
library(msigdbr)
library(org.Hs.eg.db)
library(magrittr)

# Desgin without an intercept
design <- model.matrix(~ 0 + group ) #With intercept
colnames(design) <- gsub("group", "", colnames(design))

dge <- DGEList(counts=GSE198256_count, samples = Group)

# Filter low counts
keep <- filterByExpr(dge, design=design)
table(keep)
#FALSE  TRUE 
#22967 16409 
dge <- dge[keep,,keep.lib.sizes=FALSE]

# Normalization TMM
dge <- calcNormFactors(dge, method = "TMM")


# Add more contrasts

v <- voom(dge, design, plot=TRUE)

fit <- lmFit(v, design)

contrast.matrix <- makeContrasts(Covid19AI - Healthy, 
                                 Covid193Mo - Healthy, 
                                 Covid196Mo - Healthy,
                                 Covid19AI - Covid193Mo,
                                 Covid19AI - Covid196Mo,
                                 Covid193Mo - Covid196Mo,
                                 levels=design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# Store all of them
contrast_stats <- topTable(fit2, number=nrow(dge), sort.by="none")
 
contr.matrix <- contrast.matrix
all_padj <- matrix(ncol=ncol(contr.matrix), nrow=nrow(dge))
all_fch <- matrix(ncol=ncol(contr.matrix), nrow=nrow(dge))
sig <- matrix(0, ncol=ncol(contr.matrix), nrow=nrow(dge))

for(i in 1:ncol(contr.matrix)){
  target_stats <- topTable(fit2, coef=i,number=nrow(dge), sort.by="none")
  
  all_padj[,i] <- target_stats[,"adj.P.Val"]
  all_fch[,i] <- target_stats[,"logFC"]
  sel <- intersect(which(all_padj[,i] < 0.05),which(all_fch[,i] > 1))
  sig[sel,i] <- 1
  sel2 <- intersect(which(all_padj[,i] < 0.05),which(all_fch[,i] < -1))
  sig[sel2,i] <- -1 
}

colnames(all_padj) = paste("p.adj_",colnames(contr.matrix),sep="")
colnames(all_fch) = paste("logFC_",colnames(contr.matrix),sep="")
colnames(sig) = paste("sig_",colnames(contr.matrix),sep="")

dea_results = data.frame(sig,all_padj,all_fch)
rownames(dea_results) = rownames(contrast_stats)
which(duplicated(rownames(dea_results)))


length(rownames(dea_results)[rowSums(abs(sig)!=0)>0]) #4045
list_genes <- rownames(dea_results)[apply(sig,1,FUN=function(x){return(sum(x!=0))})>0]
length(list_genes) #4045
#with a adj.pval<0.05 & |FC|>1.5 (logFC>0.1)

write.table(dea_results,paste(format(Sys.time(), "%Y%m%d"),"_dea_results.txt",sep=""),sep="\t", dec=".", quote=FALSE, row.names=TRUE, col.names=TRUE)
write.table(rownames(dea_results[list_genes,]),"list_deg.txt",sep="\t",dec=".",quote=FALSE, row.names=FALSE, col.names=FALSE)

# 



```

## ORA and Gene Set Enrichment analysis.

-   What do we need to do the analysis?
ORA: We need a set of **genes from our analysis** that we want to invesitagte, e.g. list of differentially expressed genes that we found to be significant, while comparing two groups of samples. Additionally we need **background genes**, which will serve as an universe for the analysis. Those genes can be a whole genome, or they can be narrowed down to all of the genes expressed in your samples, for a higher specificity. And finally we need a dataset of geneset pathways, processed, singatures, which we want to investigate for enrichment in our genes of interested.  

GSEA: We need a **ranked list** of **genes from our analysis**, which are ranked according to statistics based on their phenotypes. And finally we need a dataset of geneset pathways, processed, signatures, which we want to use to investigate their enrichment in our genes of interested. 

-   What are the tools required?
We need tools such as clusterProfiler and onotolgogy data base, such as GO, KEGG, etc.

```{r Prepare ORA and GSEA}

keytypes(org.Hs.eg.db)

# If we want to shift annotations:
ENSEMBL_vector <- mapIds(
  # Replace with annotation package for the organism relevant to your data
  org.Hs.eg.db,
  # The vector of gene identifiers we want to map
  keys = rownames(GSE198256_count),
  # Replace with the type of gene identifiers in your data
  keytype = "ENTREZID",
  # Replace with the type of gene identifiers you would like to map to
  column = "ENSEMBL",
  # In the case of 1:many mappings, return the
  # first one. This is default behavior!
  multiVals = "first"
)

# We would like a data frame we can join to the differential expression stats
gene_key_df <- data.frame(
  ensembl_id = ENSEMBL_vector,
  entrez_id = names(ENSEMBL_vector),
  stringsAsFactors = FALSE
) %>%
  # If an Ensembl gene identifier doesn't map to a gene symbol, drop that
  # from the data frame
  dplyr::filter(!is.na(ensembl_id))


```

## Lets conduct ORA.

```{r Run ORA}

# Step 1: determine genes of interest.

diff_table <- topTable(fit2,coef=1,p.value=0.01,number=10000) # Differentially expressed genes for the first contrast #Covid19AI - Healthy
genes_dif <- rownames(diff_table) #635

# Step 2: determine background.

background_set <- unique(rownames(dge)) #16409

# Step 3: Determine gene sets.

hs_msigdb_df <- msigdbr(species = "Homo sapiens")
#head(hs_msigdb_df)

hs_kegg_df <- hs_msigdb_df %>%
  dplyr::filter(
    gs_cat == "C2", # This is to filter only to the C2 curated gene sets
    gs_subcat == "CP:KEGG" # This is because we only want KEGG pathways
)

# Step 4: conduct ORA.

kegg_ora_results <- enricher(
  gene = genes_dif, # A vector of your genes of interest
  pvalueCutoff = 0.1, # Can choose a FDR cutoff
  pAdjustMethod = "BH", # Method to be used for multiple testing correction
  universe = background_set, # A vector containing your background set genes
  # The pathway information should be a data frame with a term name or
  # identifier and the gene identifiers
  TERM2GENE = dplyr::select(
    hs_kegg_df,
    gs_name,
    human_entrez_gene
  )
)


# Step 5: Visualize / explore

enrich_plot <- enrichplot::dotplot(kegg_ora_results)
enrich_plot

upset_plot <- enrichplot::upsetplot(kegg_ora_results)
upset_plot

# Step 6: EXERCISE: alternatives to KEGG?

# note: see mor examples: https://alexslemonade.github.io/refinebio-examples/03-rnaseq/pathway-analysis_rnaseq_01_ora.html#46_Over-representation_Analysis_(ORA) 

# ORA with GO terms
#enrichment analysis
ego <- enrichGO(gene          = genes_dif,
                universe      = background_set,
                OrgDb         = org.Hs.eg.db,
                ont           = "BP",
                pAdjustMethod = "fdr",
                pvalueCutoff  = 0.1,
                qvalueCutoff  = 0.1,
                minGSSize     = 15,
                maxGSSize     = 500,
                readable      = TRUE)

# results
#head(ego)[, 1:7]


#plotting adj p-values and gene ratio
dotplot(ego)

#plotting adj p-values and count
barplot(ego, 
        drop = TRUE, 
        showCategory = 10, 
        title = "GO Biological Pathways",
        font.size = 8)

```

## Lets conduct GSEA.

```{r run GSEA}


# Step 1: determine genes of interest for the same dataset as ORA
diff_table_all <- topTable(fit2,coef=1,p.value=1,number=nrow(dge)) 

# Step 2: determine background.

# Step 3: Determine gene sets.

msigdbr_species()
hs_msigdb_df <- msigdbr(species = "Homo sapiens")
head(hs_msigdb_df)

hs_kegg_df <- hs_msigdb_df %>%
  dplyr::filter(
    gs_cat == "C2", # This is to filter only to the C2 curated gene sets
    gs_subcat == "CP:KEGG" # This is because we only want KEGG pathways
  )

# Step 4: conduct GSEA

list_ordered <- diff_table_all[,"B"]
names(list_ordered) <- rownames(diff_table_all)
  
  
gsea_results <- GSEA(
  geneList = list_ordered, # Ordered ranked gene list
  minGSSize = 25, # Minimum gene set size
  maxGSSize = 500, # Maximum gene set set
  pvalueCutoff = 0.05, # p-value cutoff
  eps = 0, # Boundary for calculating the p value
  seed = TRUE, # Set seed to make results reproducible
  pAdjustMethod = "BH", # Benjamini-Hochberg correction
  TERM2GENE = dplyr::select(
    hs_kegg_df,
    gs_name,
    human_entrez_gene
  )
)



# Step 5: Visualize / explore


head(gsea_results@result)

gsea_result_df <- data.frame(gsea_results@result)
gsea_result_df %>%
  # This returns the 3 rows with the largest NES values
  dplyr::slice_max(NES, n = 3)

most_positive_nes_plot <- enrichplot::gseaplot(
  gsea_results,
  geneSetID = "KEGG_JAK_STAT_SIGNALING_PATHWAY",
  title = "KEGG_JAK_STAT_SIGNALING_PATHWAY",
  color.line = "#0d76ff"
)
most_positive_nes_plot

gsea_result_df %>%
  # Return the 3 rows with the smallest (most negative) NES values
  dplyr::slice_min(NES, n = 3)

most_negative_nes_plot <- enrichplot::gseaplot(
  gsea_results,
  geneSetID = "KEGG_SPLICEOSOME",
  title = "KEGG_SPLICEOSOME",
  color.line = "#0d76ff"
)
most_negative_nes_plot


# Step 6: EXERCISE: alternatives to KEGG?

# Gene Ontology
ego3 <- gseGO(geneList     = list_ordered,
              OrgDb        = org.Hs.eg.db,
              ont          = "BP",
              minGSSize    = 25,
              maxGSSize    = 500,
              pvalueCutoff = 0.05,
              verbose      = FALSE)


#plotting adj p-values and gene ratio
dotplot(ego3)

#plotting adj p-values and count
barplot(ego3, 
        drop = TRUE, 
        showCategory = 10, 
        title = "GO Biological Pathways",
        font.size = 8)


# Step 7: EXERCISE: compare GSEA vs ORA?

shared_ora_gsea <- intersect(gsea_results$ID, kegg_ora_results@result$ID)

length(shared_ora_gsea) # There are 54 genesets identified in both analysis

dim(gsea_results) #57 x 11
dim(kegg_ora_results@result) #147 x 9 

shared_ora_gsea_sig <- intersect(gsea_results[gsea_results$p.adjust < 0.05 ,]$ID, kegg_ora_results@result[ kegg_ora_results@result$p.adjust < 0.05,]$ID)

length(shared_ora_gsea_sig) #1

# Only 1 gene set is significant in both analysis
# "KEGG_LEISHMANIA_INFECTION"

enrichplot::gseaplot(
  gsea_results,
  geneSetID = "KEGG_LEISHMANIA_INFECTION",
  title = "KEGG_LEISHMANIA_INFECTION",
  color.line = "#0d76ff")

gsea_results["KEGG_LEISHMANIA_INFECTION",]

# From the GSEA analysis, we see that KEGG_LEISHMANIA_INFECTION geneset is overrepresented at the bottom of ranked list of genes with the Normalzied Enrichment Score = -1.57 and adjusted p.value = 0.032

enrichplot::upsetplot(kegg_ora_results)

kegg_ora_results@result["KEGG_LEISHMANIA_INFECTION",]
# From ORA anlysis, we see that 13 genes from our differentially expressed genes are significantly overrepresented in the KEGG_LEISHMANIA_INFECTION geneset with the adjusted p.value = 0.0074.

```

## Lets conduct GeneSetCluster.

```{r prepare GSEA}

# We prepare a function from the previous analysis

# Covid19AI vs Healthy
Diff_AIvsH <- topTable(fit2,coef=1,p.value=1,number=nrow(logCPM))
# Covid196Mo vs Healthy
Diff_6MovsH <- topTable(fit2,coef=3,p.value=1,number=nrow(logCPM))


hs_msigdb_df <- msigdbr(species = "Homo sapiens")
hs_kegg_df <- hs_msigdb_df %>%
  dplyr::filter(
    gs_cat == "C2", # This is to filter only to the C2 curated gene sets
    gs_subcat == "CP:KEGG" # This is because we only want KEGG pathways
  )


doGSEA <- function(diff_table) {
  list_ordered <- diff_table[,"B"]
  names(list_ordered) <- rownames(diff_table)
  
  return(GSEA(
    geneList = list_ordered, # Ordered ranked gene list
    minGSSize = 25, # Minimum gene set size
    maxGSSize = 500, # Maximum gene set set
    pvalueCutoff = 0.05, # p-value cutoff
    eps = 0, # Boundary for calculating the p value
    seed = TRUE, # Set seed to make results reproducible
    pAdjustMethod = "BH", # Benjamini-Hochberg correction
    TERM2GENE = dplyr::select(
      hs_kegg_df,
      gs_name,
      human_entrez_gene
    )
  ))
}

GSEA_AIvsH <- doGSEA(Diff_AIvsH)
GSEA_6MovsH <- doGSEA(Diff_6MovsH)


path <- "/Users/kurowsaa/OneDrive/Documents/KAUST/Bioinfo_pipelines_course/WEEK 2"

write.csv(GSEA_AIvsH, file = paste0(path, "/GSEA_AIvsH.csv"), row.names = FALSE)
write.csv(GSEA_6MovsH, file = paste0(path, "/GSEA_6MovsH.csv"), row.names = FALSE)
```

```{r install GeneSetCluster}
######## Check if the required packages are installed ########
#packages <- c("limma","stats","methods","RColorBrewer","clusterProfiler","GGally",
#              "network","clustree","readxl","org.Hs.eg.db",
#              "org.Mm.eg.db","cluster","factoextra","STRINGdb","WebGestaltR","stringr",
#              "AnnotationDbi","ComplexHeatmap","GO.db","GetoptLong","bigstatsr","colorRamp2",
#              "cowplot","doParallel","dplyr","foreach","ggdendro","ggnewscale","ggplot2",
#              "ggtree","ggwordcloud","grid","httr","jsonlite","parallel","patchwork","pbapply",
#              "reshape2","rgl","seriation","simplifyEnrichment","slam","tidyverse","umap",
#               "utils","grDevices")

#new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]

#install.packages(new.packages)

#path <- "/Users/kurowsaa/OneDrive/Documents/KAUST/Bioinfo_pipelines_course/WEEK 2"
#install.packages(path, repos=NULL, type='source')

```

```{r run GeneSetCluster}
library(GeneSetCluster)
path <- "/Users/kurowsaa/OneDrive/Documents/KAUST/Bioinfo_pipelines_course/WEEK 2"
GSEA.files <- paste0(path, "/", list.files(path, pattern = ".csv"))

# Load the data and create Pathway object
# Automatically for GSEA, GREAT or IPA
GSEA.Object1 <- LoadGeneSets(file_location = GSEA.files, 
                              groupnames= c("GSEA_Hvs6Mo", "GSEA_HvsAI"), # names of the groups
                              P.cutoff = 0.05, # cut off the p.adjust
                              Mol.cutoff = 15, # minimum number of genes per pathway
                              Source = "GSEA", # the analysis (GSEA, GREAT or IPA)
                              structure = "ENTREZID", # Gene type (SYMBOL, ENTREZID, ENSEMBLID)
                              Organism = "org.Hs.eg.db", # database: Homo Sapiens or Mus musculus
                              seperator = "/") # the separator used for listing genes

# IMPORTANT when created manually, it is assumed that the pathways have been filtered by p-value and minimum number of genes per pathway
# Make sure you have filtered your data
#GSEA.Object1Manual <- ObjectCreator(Pathways = c(GSEA_HvsAI@result$ID, 
#                                                 GSEA_Hvs6Mo@result$ID),
#                                    Molecules = c(GSEA_HvsAI@result$core_enrichment, 
#                                                  GSEA_Hvs6Mo@result$core_enrichment),
#                                    Groups = c(rep("GSEA_HvsAI", times=nrow(GSEA_HvsAI@result)), 
#                                               rep("GSEA_Hvs6Mo", times=nrow(GSEA_Hvs6Mo@result))),
#                                    Pvalues = c(GSEA_HvsAI@result$p.adjust,  # optional
#                                                GSEA_Hvs6Mo@result$p.adjust),
#                                    enrichmentScore = c(GSEA_HvsAI@result$NES, # optional
#                                                       GSEA_Hvs6Mo@result$NES), 
#                                    structure = "ENTREZID", Type = "", sep = "/",
#                                    Source = "GSEA", organism = "org.Hs.eg.db")

GSEA.Object2 <- CombineGeneSets(Object = GSEA.Object1,
                                combineMethod = "Standard", threads = 8)


OptimalGeneSets(Object = GSEA.Object2, 
                uniquePathway = FALSE, # consider all the pathways (also repeated) or the unique pathways
                method = "silhouette", max_cluster= 24, cluster_method = "kmeans", main= "Kmeans for 24 clusters")

OptimalGeneSets(Object = GSEA.Object2, 
                uniquePathway = TRUE, # consider all the pathways (also repeated) or the unique pathways
                method = "silhouette", max_cluster= 24, cluster_method = "kmeans", main= "Kmeans for 24 clusters")

# in both cases the optimal cluster is 2

GSEA.Object3 <- ClusterGeneSets(Object = GSEA.Object2, 
                                clusters = 2, # consider all the pathways (also repeated) or the unique pathways
                                method = "Hierarchical", # Hierarchical clustering or kmeans
                                order = "cluster",
                                molecular.signature = "All")


# plot results for both all pathways and unique pathways
plotnounique <- PlotGeneSets(GSEA.Object3, 
                             uniquePathways = FALSE, 
                             wordcloud = FALSE, # wordcloud only supported for GO terms
                             doORA = T) # do ora per cluster

plotunique <- PlotGeneSets(GSEA.Object3, 
                           uniquePathways = TRUE, 
                           wordcloud = FALSE, # wordcloud only supported for GO terms
                           doORA = T) # do ora per cluster


# let's say we are interested in exploring cluster 2 in plotunique. Lets break up this cluster for further analysis 

plotoptimalcluster2 <- OptimalGeneSets(Object = GSEA.Object3, 
                uniquePathway = TRUE, # consider all the pathways (also repeated) or the unique pathways
                cluster = 2, # which cluster
                method = "silhouette", max_cluster= 24, cluster_method = "kmeans", main= "Kmeans for 24 clusters in cluster 1")

plotoptimalcluster2 # optimal 2 break up cluster 2 in 2 clusters

GSEA.Object3breakup <- BreakUpCluster(GSEA.Object3, 
                                      breakup.cluster = 2, # which cluster
                                      sub.cluster = 2, # in how many cluster split up
                                      uniquePathways = TRUE) # conside unique pathways

plotuniquebreakup <- PlotGeneSets(GSEA.Object3breakup, 
                                  uniquePathways = TRUE, 
                                  wordcloud = FALSE, # wordcloud only supported for GO terms
                                  doORA = T) # do ora per cluster

plotuniquebreakup

# Now break up the cluster 1 
plotoptimalcluster1 <- OptimalGeneSets(Object = GSEA.Object3, 
                uniquePathway = TRUE, # consider all the pathways (also repeated) or the unique pathways
                cluster = 1, # which cluster
                method = "silhouette", max_cluster= 24, cluster_method = "kmeans", main= "Kmeans for 24 clusters in cluster 1")

plotoptimalcluster1 # optimal 1 break up cluster 1 in 17 clusters

GSEA.Object3breakup2 <- BreakUpCluster(GSEA.Object3breakup, 
                                      breakup.cluster = 1, # which cluster
                                      sub.cluster = 17, # in how many cluster split up
                                      uniquePathways = TRUE) # conside unique pathways

plotuniquebreakup2 <- PlotGeneSets(GSEA.Object3breakup2, 
                                   uniquePathways = TRUE, 
                                   wordcloud = FALSE, # wordcloud only supported for GO terms
                                   doORA = T) # do ora per cluster

plotuniquebreakup2


```


```{r explore results}
# plot results for both all pathways and unique pathways
plotnounique <- PlotGeneSets(GSEA.Object3, 
                             uniquePathways = FALSE, 
                             wordcloud = FALSE, # wordcloud only supported for GO terms
                             doORA = T) # do ora per cluster

plotunique <- PlotGeneSets(GSEA.Object3, 
                           uniquePathways = TRUE, 
                           wordcloud = FALSE, # wordcloud only supported for GO terms
                           doORA = T) # do ora per cluster


# let's say we are interested in exploring cluster 2 in plotunique. Lets break up this cluste for further analysis 

plotoptimalcluster2 <- OptimalGeneSets(Object = GSEA.Object3, 
                uniquePathway = TRUE, # consider all the pathways (also repeated) or the unique pathways
                cluster = 2, # which cluster
                method = "silhouette", max_cluster= 24, cluster_method = "kmeans", main= "Kmeans for 24 clusters in cluster 1")

plotoptimalcluster2 # optimal 2 break up cluster 2 in 2 clusters

GSEA.Object3breakup <- BreakUpCluster(GSEA.Object3, 
                                      breakup.cluster = 2, # which cluster
                                      sub.cluster = 2, # in how many cluster split up
                                      uniquePathways = TRUE) # conside unique pathways

plotuniquebreakup <- PlotGeneSets(GSEA.Object3breakup, 
                                  uniquePathways = TRUE, 
                                  wordcloud = FALSE, # wordcloud only supported for GO terms
                                  doORA = T) # do ora per cluster

plotuniquebreakup

# Now break up the cluster 1 
plotoptimalcluster1 <- OptimalGeneSets(Object = GSEA.Object3, 
                uniquePathway = TRUE, # consider all the pathways (also repeated) or the unique pathways
                cluster = 1, # which cluster
                method = "silhouette", max_cluster= 24, cluster_method = "kmeans", main= "Kmeans for 24 clusters in cluster 1")

plotoptimalcluster1 # optimal 1 break up cluster 1 in 9 clusters

GSEA.Object3breakup2 <- BreakUpCluster(GSEA.Object3breakup, 
                                      breakup.cluster = 1, # which cluster
                                      sub.cluster = 9, # in how many cluster split up
                                      uniquePathways = TRUE) # conside unique pathways

plotuniquebreakup2 <- PlotGeneSets(GSEA.Object3breakup2, 
                                   uniquePathways = TRUE, 
                                   wordcloud = FALSE, # wordcloud only supported for GO terms
                                   doORA = T) # do ora per cluster

plotuniquebreakup2


```


```{r breakup cluster number 1}
# let's say we are interested in exploring cluster 2 in plotunique. Lets break up this cluste for further analysis 

plotoptimalcluster2 <- OptimalGeneSets(Object = GSEA.Object3, 
                uniquePathway = TRUE, # consider all the pathways (also repeated) or the unique pathways
                cluster = 2, # which cluster
                method = "silhouette", max_cluster= 24, cluster_method = "kmeans", main= "Kmeans for 24 clusters in cluster 1")

plotoptimalcluster2 # optimal 2 break up cluster 2 in 2 clusters

GSEA.Object3breakup <- BreakUpCluster(GSEA.Object3, 
                                      breakup.cluster = 2, # which cluster
                                      sub.cluster = 2, # in how many cluster split up
                                      uniquePathways = TRUE) # conside unique pathways

plotuniquebreakup <- PlotGeneSets(GSEA.Object3breakup, 
                                  uniquePathways = TRUE, 
                                  wordcloud = FALSE, # wordcloud only supported for GO terms
                                  doORA = T) # do ora per cluster

plotuniquebreakup
```


# sample-code
# sample-code
